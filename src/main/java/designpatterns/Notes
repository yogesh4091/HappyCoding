1.	Identify the aspect of your application that vary and separate them from what stays the same.
2.	Program to an interface ,  not to an implementation.
3.	Favor Composition over inheritance as it lets you change behavior at runtime.
4.	Loosely coupled designs allow us to build flexible OO  systems that can handle change
    because they minimize the interdependency between objects.
5.	Classes should be open for extension but closed for modification.


STRATEGY DESIGN PATTERN:
The Strategy Pattern defines a family of algorithms ,encapsulates each one, and makes them interchangeable.
Strategy lets the algorithm vary independently from clients that use it.
Example : SimUDuck App – Using FlyBehavior and QuackBehavior interfaces using composition.

OBSERVER PATTERN:
The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state,
all of its dependents are notified and updated automatically.
Example : Broadcaster and observers as ESPNCricInfo/Cricbuzz.

DECORATOR PATTERN:
The Decorator pattern attaches additional responsibility to an object dynamically.
Decorators provide a flexible alternative to sub-classing for extending functionality.
Example : Starbucks and Different flavors of coffee. InputStream API. Criteria API.

FACTORY PATTERN:
The Factory Method Pattern defines an interface for creating an object, but let’s subclasses decide which class to instantiate.
Factory Method lets a class defer instantiation to subclasses.

ADAPTER PATTERN:
The Adapter pattern converts the interface of a class into another interface the client expect.
Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.
Example : Use of adapter to make memory card work as a pen drive.

FAÇADE PATTERN:
The Facade design pattern is often used when a system is very complex or difficult to understand
because the system has a large number of interdependent classes or its source code is unavailable.
This pattern hides the complexities of the larger system and provides a simpler interface to the client.
It typically involves a single wrapper class which contains a set of members required by client.

SINGLETON PATTERN:
The Singleton Pattern ensures a class has only one instance, and provides a global point of access to it.

Breaking Singleton : 1. Using different class loader.
                     2. Using Clone.
                     3. Using Reflection.
                     4. Using Serializable.
